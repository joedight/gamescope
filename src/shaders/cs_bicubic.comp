// References
// https://www.codeproject.com/Articles/236394/Bi-Cubic-and-Bi-Linear-Interpolation-with-GLSL
// https://stackoverflow.com/questions/13501081/efficient-bicubic-filtering-code-in-glsl

#version 460

#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : require

#include "descriptor_set.h"

layout(
  local_size_x = 64,
  local_size_y = 1,
  local_size_z = 1) in;

layout(push_constant)
uniform layers_t {
    uvec4 c0, c1, c2, c3, c4, c5, c6, c7, c8, c9;
};

#define A_GPU 1
#define A_GLSL 1
#define A_HALF 1
#include "ffx_a.h"
#include "bicubic.h"

vec4 catMullRom( float x )
{
    vec4 n = vec4(1.0, 2.0, 3.0, 4.0) - x;
    const float B = 0.0;
    const float C = 0.5;
    float f = x;
    if( f < 0.0 )
    {
        f = -f;
    }
    if( f < 1.0 )
    {
        return n * ( ( 12 - 9 * B - 6 * C ) * ( f * f * f ) +
            ( -18 + 12 * B + 6 *C ) * ( f * f ) +
            ( 6 - 2 * B ) ) / 6.0;
    }
    else if( f >= 1.0 && f < 2.0 )
    {
        return n * ( ( -B - 6 * C ) * ( f * f * f )
            + ( 6 * B + 30 * C ) * ( f *f ) +
            ( - ( 12 * B ) - 48 * C  ) * f +
            8 * B + 24 * C)/ 6.0;
    }
    else
    {
        return n * 0.0;
    }
}


vec4 textureBicubic(sampler2D splr, vec2 texCoords)
{

   vec2 texSize = textureSize(splr, 0);
   vec2 invTexSize = 1.0 / texSize;

   texCoords = texCoords * texSize - 0.5;


    vec2 fxy = fract(texCoords);
    texCoords -= fxy;

    vec4 xcubic = catMullRom(fxy.x);
    vec4 ycubic = catMullRom(fxy.y);

    vec4 c = texCoords.xxyy + vec2 (-0.5, +1.5).xyxy;

    vec4 s = vec4(xcubic.xz + xcubic.yw, ycubic.xz + ycubic.yw);
    vec4 offset = c + vec4 (xcubic.yw, ycubic.yw) / s;

    offset *= invTexSize.xxyy;

    vec4 sample0 = texture(splr, offset.xz);
    vec4 sample1 = texture(splr, offset.yz);
    vec4 sample2 = texture(splr, offset.xw);
    vec4 sample3 = texture(splr, offset.yw);

    float sx = s.x / (s.x + s.y);
    float sy = s.z / (s.z + s.w);

    return mix(
       mix(sample3, sample2, sx), mix(sample1, sample0, sx)
    , sy);
}

void bicPass(uvec2 pos)
{
    AF3 color;

    AF2 pp=AF2(pos)*AF2_AU2(c0.xy)+AF2_AU2(c0.zw);
    AF2 fp=floor(pp);
    pp-=fp;
    AF2 p0=fp*AF2_AU2(c1.xy)+AF2_AU2(c1.zw);
    AF2 p1=p0+AF2_AU2(c2.xy);
    AF2 p2=p0+AF2_AU2(c2.zw);
    AF2 p3=p0+AF2_AU2(c3.xy);
    AF2 p4=p0+AF2_AU2(c3.zw);
    AF2 p5=p0+AF2_AU2(c4.xy);
    AF2 p6=p0+AF2_AU2(c4.zw);
    AF2 p7=p0+AF2_AU2(c5.xy);
    AF2 p8=p0+AF2_AU2(c5.zw);
    AF2 p9=p0+AF2_AU2(c6.xy);
    AF2 p10=p0+AF2_AU2(c6.zw);
    AF2 p11=p0+AF2_AU2(c7.xy);
    AF2 p12=p0+AF2_AU2(c7.zw);
    AF2 p13=p0+AF2_AU2(c8.xy);
    AF2 p14=p0+AF2_AU2(c8.zw);
    AF2 p15=p0+AF2_AU2(c9.xy);

    vec4 bic0 = textureBicubic(s_samplers[0], p0);
    vec4 bic1 = textureBicubic(s_samplers[0], p1);
    vec4 bic4 = textureBicubic(s_samplers[0], p4);
    vec4 bic5 = textureBicubic(s_samplers[0], p5);

    if ( AF1_AU1(c0[1]) >= 4 )
    {
        vec4 bic2 = textureBicubic(s_samplers[0], p2);
        vec4 bic3 = textureBicubic(s_samplers[0], p3);
        vec4 bic6 = textureBicubic(s_samplers[0], p6);
        vec4 bic7 = textureBicubic(s_samplers[0], p7);
        vec4 bic8 = textureBicubic(s_samplers[0], p8);
        vec4 bic9  = textureBicubic(s_samplers[0], p9);
        vec4 bic10 = textureBicubic(s_samplers[0], p10);
        vec4 bic11 = textureBicubic(s_samplers[0], p11);
        vec4 bic12 = textureBicubic(s_samplers[0], p12);
        vec4 bic13 = textureBicubic(s_samplers[0], p13);
        vec4 bic14 = textureBicubic(s_samplers[0], p14);
        vec4 bic15 = textureBicubic(s_samplers[0], p15);

        // 4x4 bicubic
        imageStore(dst, ivec2(pos),
        (bic4+bic8+bic0+bic1+bic6+bic3+bic5+bic7+bic2+bic9+bic10+bic11+bic12+bic13+bic14+bic15)/16);
    }
    else if ( AF1_AU1(c0[1]) >= 3 )
    {
        vec4 bic2 = textureBicubic(s_samplers[0], p2);
        vec4 bic6 = textureBicubic(s_samplers[0], p6);
        vec4 bic8 = textureBicubic(s_samplers[0], p8);
        vec4 bic9  = textureBicubic(s_samplers[0], p9);
        vec4 bic10 = textureBicubic(s_samplers[0], p10);

        // 3x3 bicubic
        imageStore(dst, ivec2(pos),
        (bic0+bic1+bic2+bic4+bic5+bic6+bic8+bic9+bic10)/9);
    }
    else
    {
        // 2x2 bicubic
        imageStore(dst, ivec2(pos), (bic0+bic1+bic4+bic5)/4);
        // imageStore(dst, ivec2(pos), textureBilinear(s_samplers[0], p1));
        // imageStore(dst, ivec2(pos), texture(s_samplers[0], p1));
        // imageStore(dst, ivec2(pos), texture(s_samplers[0], vec2(0.0,0.0)));
    }
}


void main()
{
    // AMD recommends to use this swizzle and to process 4 pixel per invocation
    // for better cache utilisation
    uvec2 pos = ARmp8x8(gl_LocalInvocationID.x) + uvec2(gl_WorkGroupID.x << 4u, gl_WorkGroupID.y << 4u);

    bicPass(pos);
    pos.x += 8u;
    bicPass(pos);
    pos.y += 8u;
    bicPass(pos);
    pos.x -= 8u;
    bicPass(pos);
}
